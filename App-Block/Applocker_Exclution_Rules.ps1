<#
.AppName
  AppLocker-MultiRule.ps1
.Description
  Create and append one or more AppLocker File Path rules to the current effective AppLocker policy.
  Supports multiple rule types (Exe, Dll, Script, Msi, Appx) and multiple paths per rule type.
  NOTE: Appx/packaged-app rules require a different structure and are only sketched here.
.Usage
  Edit the variables in the "CHANGE THESE" section, save and run as Administrator.
#>

# --- CHANGE THESE VARIABLES ---
# You may provide a single value or an array for $ruleTypes and $targetPaths
$ruleTypes      = @("Exe")       # Options: Exe, Dll, Script, Msi, Appx
$action         = "Allow"        # Allow or Deny
$ruleNameBase   = ""             # If empty, the script will autogenerate a full friendly name from path/app and rule type
$description    = ""             # If empty, the script will autogenerate a description from path/app and rule type
$targetPaths    = @("C:\*", "%PROGRAMFILES%\Notepad++\notepad++.exe")  # one or more paths/wildcards or Appx package family names
$userOrGroupSid = "S-1-1-0"     # Default Everyone
$outFile        = "$env:Temp\AppLocker-Patched.xml"

# --- Do not change below unless you know what you're doing ---

try {
    Write-Host "Exporting effective AppLocker policy..."
    $xml = Get-AppLockerPolicy -Effective -Xml
} catch {
    Write-Error "Failed to export AppLocker policy. Are you running as Administrator and is AppLocker available on this edition of Windows? $_"
    exit 1
}

$policy = [xml]$xml

# helper to find collection by type
function Get-RuleCollectionByType($policyXml, $type) {
    return $policyXml.AppLockerPolicy.RuleCollection | Where-Object { $_.Type -eq $type }
}

# sanitize a name part derived from a path or package name
function Get-SafeNamePart($raw, $isPath) {
    if ($isPath) {
        # Prefer last segment of path if present, otherwise fallback to full path
        $fn = [IO.Path]::GetFileName($raw)
        if ([string]::IsNullOrWhiteSpace($fn)) { $fn = $raw }
    } else {
        # For Appx/package names use the raw string
        $fn = $raw
    }
    # Replace characters that would be problematic in rule names
    $safe = $fn -replace '[\\/:*?"<>|\s]+','_' -replace '[^0-9A-Za-z_\-\.]',''
    return $safe
}

# track if we added any rules
$added = 0

foreach ($ruleType in $ruleTypes) {
    # Validate target collection exists
    $targetCollection = Get-RuleCollectionByType $policy $ruleType
    if (-not $targetCollection) {
        Write-Warning "Rule collection for type '$ruleType' not found in current policy. Skipping this type."
        continue
    }

    # For each path create a separate rule
    foreach ($p in $targetPaths) {
        $isAppx = ($ruleType -eq 'Appx')

        # Derive a safe name part from path or package family name
        $safeNamePart = Get-SafeNamePart $p (-not $isAppx)

        # Build autogenerated friendly name and description. If user provided $ruleNameBase or $description, keep them as a prefix.
        if ([string]::IsNullOrWhiteSpace($ruleNameBase)) {
            $finalName = "${action} ${safeNamePart} (${ruleType})"
        } else {
            $finalName = "${ruleNameBase} - ${safeNamePart} (${ruleType})"
        }

        if ([string]::IsNullOrWhiteSpace($description)) {
            $finalDescription = "${action} ${ruleType} rule for ${safeNamePart} (Path/Package: ${p})"
        } else {
            $finalDescription = "${description} - ${safeNamePart} (Path/Package: ${p})"
        }

        # Create the rule element
        if ($isAppx) {
            $ruleElementName = 'AppxPackageRule'
        } else {
            $ruleElementName = 'FilePathRule'
        }

        $newRule = $policy.CreateElement($ruleElementName)
        $newRule.SetAttribute('Id', ([guid]::NewGuid().ToString()))
        $newRule.SetAttribute('Name', $finalName)
        $newRule.SetAttribute('Description', $finalDescription)
        $newRule.SetAttribute('UserOrGroupSid', $userOrGroupSid)
        $newRule.SetAttribute('Action', $action)

        # Conditions container
        $conditions = $policy.CreateElement('Conditions')

        if (-not $isAppx -and ($ruleType -in @('Exe','Dll','Script','Msi'))) {
            $condition = $policy.CreateElement('FilePathCondition')
            $condition.SetAttribute('Path', $p)
            $conditions.AppendChild($condition) | Out-Null
            $newRule.AppendChild($conditions) | Out-Null

            # Append to collection
            $targetCollection.AppendChild($newRule) | Out-Null
            Write-Host "Added $ruleType rule for path: $p (Name: $finalName)"
            $added++
        }
        elseif ($isAppx) {
            # Appx packaged app rules require a different XML structure (AppLocker uses AppxPackageRule)
            $pfCondition = $policy.CreateElement('PackageFamilyNameCondition')
            $pfCondition.SetAttribute('PackageFamilyName', $p)
            $conditions.AppendChild($pfCondition) | Out-Null
            $newRule.AppendChild($conditions) | Out-Null

            $targetCollection.AppendChild($newRule) | Out-Null
            Write-Host "Added Appx rule for package family: $p (Name: $finalName)"
            $added++
        }
        else {
            Write-Warning "Unsupported or unknown rule type '$ruleType' â€” skipping path $p."
        }
    }
}

if ($added -eq 0) {
    Write-Warning "No rules were added. Exiting without writing policy."
    exit 0
}

# Save modified policy to file (backup original first)
try {
    if (Test-Path $outFile) { Copy-Item -Path $outFile -Destination "$outFile.bak" -Force }
    $policy.OuterXml | Out-File $outFile -Encoding UTF8
    Write-Host "Saved patched policy to $outFile"
} catch {
    Write-Error "Failed to write policy file: $_"
    exit 1
}

# Apply the policy
try {
    Write-Host "Applying AppLocker policy (XML from $outFile)..."
    Set-AppLockerPolicy -XmlPolicy $outFile
    gpupdate /force | Out-Null

    sc.exe config appidsvc start= auto | Out-Null
    try { Restart-Service -Name AppIDSvc -Force -ErrorAction Stop; Write-Host "AppIDSvc restarted." } catch { Write-Warning "Could not restart AppIDSvc; reboot may be required." }

    Write-Host "AppLocker policy applied in ENFORCE mode. Check Event Viewer > Microsoft > Windows > AppLocker for events."
} catch {
    Write-Error "Failed to apply AppLocker policy: $_"
    exit 1
}