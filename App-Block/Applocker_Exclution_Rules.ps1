<#
.AppName
  AppLocker-MultiRule.ps1
.Description
  Create and append one or more AppLocker File Path rules to the current effective AppLocker policy.
  Supports multiple rule types (Exe, Dll, Script, Msi, Appx/PackagedApp) and multiple paths per rule type.
.Usage
  Edit the variables in the "CHANGE THESE" section, save and run as Administrator.
#>

# --- CHANGE THESE VARIABLES ---
# You may provide a single value or an array for $ruleTypes and $targetPaths
$ruleTypes      = @("Exe", "Script", "Dll")       # Options: Exe, Dll, Script, Msi, Appx (or PackagedApp)
$action         = "Allow"        # Allow or Deny
$ruleNameBase   = ""             # If empty, the script will autogenerate a friendly name
$description    = ""             # If empty, the script will autogenerate a description
$targetPaths    = @("%OSDRIVE%\Siemens\*", "%OSDRIVE%\Java\*", "%OSDRIVE%\USERS\*\.SWT\*", "%OSDRIVE%\USERS\*\TEAMCENTER\*", "D:\ManageEngine*\*", "E:\ManageEngine*\*", "%OSDRIVE%\DEVSUITEHOME*\*", "%OSDRIVE%\QUEST_TOAD\*", "%OSDRIVE%\USERS\*\APPDATA\LOCALLOW\ORACLE\*")  # one or more paths/wildcards or Appx package family names
$userOrGroupSid = "S-1-1-0"     # Default Everyone
$outFile        = "$env:Temp\AppLocker-Patched.xml"

# --- Do not change below unless you know what you're doing ---
try {
    Write-Host "Exporting effective AppLocker policy..."
    $xml = Get-AppLockerPolicy -Effective -Xml
} catch {
    Write-Error "Failed to export AppLocker policy. Are you running as Administrator and is AppLocker available on this edition of Windows? $_"
    exit 1
}

$policy = [xml]$xml

# helper to find collection by type (robust: exact, alias, contains)
function Get-RuleCollectionByType($policyXml, $type) {
    if (-not $policyXml) { return $null }

    # try exact match first
    $node = $policyXml.SelectSingleNode("//RuleCollection[@Type='$type']")
    if ($node) { return $node }

    # common alias map (Appx vs PackagedApp)
    $aliasMap = @{ 'Appx' = 'PackagedApp'; 'PackagedApp' = 'PackagedApp' }

    if ($aliasMap.ContainsKey($type)) {
        $node = $policyXml.SelectSingleNode("//RuleCollection[@Type='$($aliasMap[$type])']")
        if ($node) { return $node }
    }

    # fallback: find any RuleCollection whose Type attribute contains the requested string (case-insensitive)
    $nodes = $policyXml.SelectNodes("//RuleCollection")
    foreach ($n in $nodes) {
        $t = $n.GetAttribute('Type')
        if ($t -and $t.ToLower().Contains($type.ToLower())) {
            return $n
        }
    }

    return $null
}

# sanitize a name part derived from a path or package name
function Get-SafeNamePart($raw, $isPath) {
    if ($isPath) {
        # Prefer last segment of path if present, otherwise fallback to full path
        $fn = [IO.Path]::GetFileName($raw)
        if ([string]::IsNullOrWhiteSpace($fn)) { $fn = $raw }
    } else {
        # For Appx/package names use the raw string
        $fn = $raw
    }
    # Replace characters that would be problematic in rule names
    $safe = $fn -replace '[\\/:*?"<>|\s]+','_' -replace '[^0-9A-Za-z_\-\.]',''
    return $safe
}

# track if we added any rules
$added = 0

# Diagnostic: list existing rule collection types (helps ensure matching names)
Write-Host "Existing RuleCollection types in current policy:"
$policy.SelectNodes("//RuleCollection") | ForEach-Object {
    Write-Host "  - $($_.GetAttribute('Type'))"
}

foreach ($ruleType in $ruleTypes) {
    # Validate target collection exists
    $targetCollection = Get-RuleCollectionByType $policy $ruleType
    if (-not $targetCollection) {
        Write-Warning "Rule collection for type '$ruleType' not found in current policy. Skipping this type."
        continue
    }

    # For each path create a separate rule
    foreach ($p in $targetPaths) {
        $isAppx = ($ruleType -eq 'Appx' -or $ruleType -eq 'PackagedApp')

        # Derive a safe name part from path or package family name
        $safeNamePart = Get-SafeNamePart $p (-not $isAppx)

        # Build autogenerated friendly name and description. If user provided $ruleNameBase or $description, keep them as a prefix.
        if ([string]::IsNullOrWhiteSpace($ruleNameBase)) {
            $finalName = "${action} ${safeNamePart} (${ruleType})"
        } else {
            $finalName = "${ruleNameBase} - ${safeNamePart} (${ruleType})"
        }

        if ([string]::IsNullOrWhiteSpace($description)) {
            $finalDescription = "${action} ${ruleType} rule for ${safeNamePart} (Path/Package: ${p})"
        } else {
            $finalDescription = "${description} - ${safeNamePart} (Path/Package: ${p})"
        }

        # Decide the element name for new rule. If the collection already contains child nodes, use the same element name as those.
        if ($targetCollection.HasChildNodes) {
            $sampleChild = $targetCollection.FirstChild
            $ruleElementName = $sampleChild.LocalName
        } else {
            # fallback defaults
            $ruleElementName = $isAppx ? 'AppxPackageRule' : 'FilePathRule'
        }

        $newRule = $policy.CreateElement($ruleElementName)
        $newRule.SetAttribute('Id', ([guid]::NewGuid().ToString()))
        $newRule.SetAttribute('Name', $finalName)
        $newRule.SetAttribute('Description', $finalDescription)
        $newRule.SetAttribute('UserOrGroupSid', $userOrGroupSid)
        $newRule.SetAttribute('Action', $action)

        # Conditions container
        $conditions = $policy.CreateElement('Conditions')

        if (-not $isAppx -and ($ruleType -in @('Exe','Dll','Script','Msi'))) {
            $condition = $policy.CreateElement('FilePathCondition')
            $condition.SetAttribute('Path', $p)
            $conditions.AppendChild($condition) | Out-Null
            $newRule.AppendChild($conditions) | Out-Null

            # Append to collection (targetCollection is an XmlElement via SelectSingleNode)
            $targetCollection.AppendChild($newRule) | Out-Null
            Write-Host "Added $ruleType rule for path: $p (Name: $finalName)"
            $added++
        }
        elseif ($isAppx) {
            # Appx packaged app rules require a different XML structure (PackageFamilyNameCondition is common)
            $pfCondition = $policy.CreateElement('PackageFamilyNameCondition')
            $pfCondition.SetAttribute('PackageFamilyName', $p)
            $conditions.AppendChild($pfCondition) | Out-Null
            $newRule.AppendChild($conditions) | Out-Null

            $targetCollection.AppendChild($newRule) | Out-Null
            Write-Host "Added Appx/PackagedApp rule for package family: $p (Name: $finalName)"
            $added++
        }
        else {
            Write-Warning "Unsupported or unknown rule type '$ruleType' â€” skipping path $p."
        }
    }
}

if ($added -eq 0) {
    Write-Warning "No rules were added. Exiting without writing policy."
    exit 0
}

# Save modified policy to file (backup original first)
try {
    if (Test-Path $outFile) { Copy-Item -Path $outFile -Destination "$outFile.bak" -Force }
    $policy.OuterXml | Out-File $outFile -Encoding UTF8
    Write-Host "Saved patched policy to $outFile"
} catch {
    Write-Error "Failed to write policy file: $_"
    exit 1
}

# Apply the policy (pass XML content, not filename)
try {
    Write-Host "Applying AppLocker policy (XML content)..."
    Set-AppLockerPolicy -XmlPolicy $policy.OuterXml -ErrorAction Stop

    # Force a group policy update and try to ensure AppIDSvc is running
    gpupdate /force | Out-Null

    sc.exe config appidsvc start= auto | Out-Null
    try {
        Restart-Service -Name AppIDSvc -Force -ErrorAction Stop
        Write-Host "AppIDSvc restarted."
    } catch {
        Write-Warning "Could not restart AppIDSvc; a reboot or manual service start may be required. $_"
    }

    Write-Host "AppLocker policy applied. Check Event Viewer > Applications and Services Logs > Microsoft > Windows > AppLocker for events."
} catch {
    Write-Error "Failed to apply AppLocker policy: $_"
    exit 1
}